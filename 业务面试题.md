# 订单支付模块







# 支付对接（微信）



服务商在

 微信支付服务商平台 - 产品中心 - 特约商户授权产品 

中发起申请，获得商户授权后，可以替商户发起服务商JSAPI支付和服务商Native支付。

## Native支付

## 1、产品概述

服务商模式Native支付，服务商为子商户（也叫特约商户）提供在PC端浏览器网页中使用微信支付收款的能力。

## 2、Native支付模式介绍

**1、**服务商下单获取订单的二维码链接code_url，将code_url转换为二维码图片展示给用户。

**2、**用户使用微信“扫一扫”进行扫码（不支持通过相册识别或长按识别二维码的方式完成支付）。

**3、**扫码进入到微信的支付确认界面，用户可在该页面确认收款方和金额。

**4、**用户确认订单收款方和金额无误后，点击“立即支付”会出现验密界面(验证密码或指纹等)，同时在该页面也可选择支付方式(零钱或银行卡等)。

**5、**验密付款成功后，微信会展示支付成功页面。

**6、**支付成功后，用户在微信支付-我的账单-账单明细中查看账单。

| 1、将code_url转换为支付二维码                                | 2、打开微信扫一扫二维码                                      | 3、进入到微信支付                                            | 4、用户确认支付                                              | 5、支付成功提示页面                                          | 6、用户在微信查看账单                                        |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| ![img](https://gtimg.wechatpay.cn/resource/xres/mmpaydoc/static/img/2cc2652105938511b590c27823bcb7dc.jpeg) | ![img](https://gtimg.wechatpay.cn/resource/xres/mmpaydoc/static/img/f1e97eedb8861ac13d7bff7ac92a8921.jpeg) | ![img](https://gtimg.wechatpay.cn/resource/xres/mmpaydoc/static/img/2efa1738b11b84e24218dbbdaef67cf4.png) | ![img](https://gtimg.wechatpay.cn/resource/xres/mmpaydoc/static/img/caf6d67060487a4891e8640ad68a7225.jpeg) | ![img](https://gtimg.wechatpay.cn/resource/xres/mmpaydoc/static/img/dda2e9c888f55825b002564dd6a6b6f5.jpeg) | ![img](https://gtimg.wechatpay.cn/resource/xres/mmpaydoc/static/img/1f4188dde09959daf09bcc0e6f7a9e95.png) |

## 3、产品接入流程

- **申请权限：**按照[权限申请](https://pay.weixin.qq.com/doc/v3/partner/4012076268)申请产品权限。
- **接入产品能力：**按照[开发指引](https://pay.weixin.qq.com/doc/v3/partner/4012076269)进行系统开发。

## 4、结算规则

- [收款资金结算规则说明](https://kf.qq.com/faq/140225MveaUz1504092YFjeM.html)

## 5、资金提现

- [收款资金提现](https://kf.qq.com/faq/161223NJBr2u161223Mfeqei.html)

下面给出一套面向 **商户 PC 网页** 的支付模块设计（针对 **微信 Native 支付**，即 PC 页面展示二维码，用户用微信扫码完成支付）。我会覆盖整体流程、前后端接口、数据库设计、重试/幂等与安全、常见边界场景和测试要点，给出可落地的实现建议和示例片段，便于直接在项目中实现。

# 

# 

# 

# 

# 

# 流程

https://pay.weixin.qq.com/doc/v3/partner/4012076269

# 参数

https://pay.weixin.qq.com/doc/v3/partner/4013080340	



# 

# 

# 

# 设计目标（要点）

- PC 端展示二维码供用户扫码（WeChat Native — `trade_type=NATIVE`）
- 后端与微信服务端交互（统一下单 unifiedorder），获取 `code_url` 并返回给前端
- 支付结果通过微信回调 `notify_url` 通知后端（服务端验证签名并更新订单）
- 前端实时显示付款状态（WebSocket / SSE / 长轮询）
- 支持重试、幂等、退款、对账与日志审计
- 强制 HTTPS、敏感信息安全存储、证书用于退款接口

---

# 1. 高层流程（序列）
1. 用户在商户 PC 页面发起“去支付”请求（选择订单/金额 + 点击支付）。
2. 前端调用商户后端 `CreateOrder` 接口（后端生成本地订单记录：`OUT_TRADE_NO`）。
3. 后端调用微信 `unifiedorder`（`trade_type=NATIVE`），传入 `out_trade_no`/`total_fee`/`notify_url`...，微信返回 `code_url`。
4. 后端把 `code_url` 返回给前端，前端用二维码库渲染二维码给用户扫码。
5. 用户用微信扫码并确认支付，微信会向商户后台 `notify_url` 发送支付结果（XML POST）。
6. 后端验证微信通知签名、金额和商户订单号，若匹配则写入数据库并触发业务（发货、通知前端等），并回复微信 `SUCCESS`。
7. 后端同时通过查询接口（`orderquery`）或推送机制告知前端支付成功（WebSocket/SSE/轮询）。
8. 支付成功后支持退款、对账和日志审计。

---

# 2. API / 接口设计（示例）
后端 REST 接口示例（HTTP/JSON）：

- `POST /api/pay/createOrder`
  - 请求：`{userId, items, totalAmount, returnUrl}`  
  - 返回：`{orderId, outTradeNo, codeUrl, expireAt}`

- `GET /api/pay/orderStatus?outTradeNo=...`
  - 返回：`{status: PENDING|PAID|CLOSED|EXPIRED|REFUNDED, paidAt, amount}`

- `POST /api/pay/notify`  <-- 微信回调 URL（接收 XML）
  - 微信回调后端处理（必须返回微信定义的 XML 响应）

- `POST /api/pay/refund`
  - 请求：`{outTradeNo, refundAmount, reason}`
  - 返回：`{refundId, status}`

- `GET /api/pay/query?outTradeNo=...` （调用微信 orderquery，用于对账/手动查询）

备注：
- `createOrder` 为幂等（如果收到重复创建请求，应返回相同 `outTradeNo` 或拒绝）
- 所有接口必须强制 HTTPS

---

# 3. 与微信交互（关键点）
- 下单（unifiedorder）核心参数（XML）：
  - `appid`, `mch_id`, `nonce_str`, `sign`, `body`, `out_trade_no`, `total_fee`（单位：分）, `spbill_create_ip`, `notify_url`, `trade_type=NATIVE`, `product_id`
- 微信返回字段：`return_code` / `result_code` / `code_url`（当 `trade_type=NATIVE` 成功时会返回 `code_url`）
- 回调（notify）必须：
  - 验签（使用商户 API key 按微信签名规则计算并比对）
  - 检查 `return_code==SUCCESS` 且 `result_code==SUCCESS`
  - 校验 `out_trade_no`、`total_fee` 与本地订单一致
  - 幂等更新本地订单状态（若已更新过则直接返回 SUCCESS）
  - 返回给微信 `<?xml version="1.0" encoding="UTF-8"?><xml><return_code><![CDATA[SUCCESS]]></return_code><return_msg><![CDATA[OK]]></return_msg></xml>`

示例：unifiedorder 请求示意（伪 XML / 关键字段）
```xml
<xml>
  <appid>YOUR_APPID</appid>
  <mch_id>YOUR_MCH_ID</mch_id>
  <nonce_str>random123</nonce_str>
  <sign>...</sign>
  <body>订单描述</body>
  <out_trade_no>ORDER20251019123001</out_trade_no>
  <total_fee>100</total_fee>
  <spbill_create_ip>1.2.3.4</spbill_create_ip>
  <notify_url>https://merchant.example.com/api/pay/notify</notify_url>
  <trade_type>NATIVE</trade_type>
  <product_id>PRODUCT_001</product_id>
</xml>
```

---

# 4. 数据库表（核心字段）
建议表设计（示例 SQL 风格字段）：

`orders`：
- `id` INT PK
- `user_id` VARCHAR
- `order_no` VARCHAR (商户业务单号)
- `out_trade_no` VARCHAR (用于微信，唯一)
- `amount` INT (分)
- `currency` VARCHAR
- `status` ENUM('CREATED','PENDING','PAID','CLOSED','REFUNDED','EXPIRED')
- `created_at`, `updated_at`, `paid_at`
- `expire_at` datetime
- `meta` JSON

`payments`：
- `id`, `order_id`, `out_trade_no`, `transaction_id` (微信交易号), `pay_channel` ('WECHAT_NATIVE'), `amount`, `status`, `notify_raw` (保存回调原文), `created_at`

`refunds`：
- `id`, `order_id`, `refund_no`, `refund_id`(微信), `amount`, `status`, `req_raw`, `resp_raw`, `created_at`

`payment_notifications`：
- `id`, `out_trade_no`, `notify_data`, `verified` BOOL, `processed` BOOL, `received_at`

关键点：
- `out_trade_no` 必须唯一且能回溯到业务订单（便于对账）
- 保存微信回调原文以备审计与纠纷处理

---

# 5. 前端实现细节（PC）
- 支付按钮流程：
  1. 点击“去支付”→调用 `POST /api/pay/createOrder`，拿到 `codeUrl` 和 `expireAt`。
  2. 使用二维码库（如 `qrcode.js`）把 `codeUrl` 渲染成二维码并显示在 modal 中（带倒计时）。
  3. 同时开启实时监听支付状态：
     - 推送（优先）：WebSocket / SSE，从服务器接收支付成功事件（推荐）。
     - 备选：轮询 `GET /api/pay/orderStatus?outTradeNo=...`（每 3s~5s，超时后退避）。
  4. 支付成功后前端关闭二维码界面并跳转业务完成页。

- 二维码过期处理：
  - 后端设置订单 `expire_at`（如 10 分钟）。
  - 到期前端显示“二维码已过期，请重新支付”并提供“刷新二维码/重新下单”按钮。
  - 重新下单应生成新的 `out_trade_no`（避免重复支付风险）。

- UX 提示：
  - 明确显示订单金额、订单号和倒计时
  - 提示用户扫码后在微信中完成付款
  - 如果支付 1-2 分钟未成功，显示“如已付款请稍等”并持续检测

---

# 6. 幂等与并发保护
- `createOrder`：如果客户端重复请求同一个业务订单号，应返回同一 `out_trade_no` 或把重复判断为已经创建（根据业务决定）。
- `notify`：务必做幂等处理：
  - 在处理 notify 前先查 `payments` / `orders` 状态，若已标 `PAID` 则直接返回 `SUCCESS` 给微信。
  - 使用事务或乐观锁（例如 `status` 字段 CAS）保护并发更新。
- `refund`：微信退款接口要求客户端证书与多次重试，退款请求应为幂等（保存 `refund_no` 并记录 `refund_id`）。

---

# 7. 验证与安全要点
- 所有通信 HTTPS。
- 微信签名验证：
  - 按微信签名规则（参数字典序，拼接 key，MD5 或 HMAC-SHA256）验证 `notify` 的签名。
- 存储敏感信息（`mch_key`、证书）：
  - 不应硬编码在源码。放在安全配置中心 / 环境变量 / 密钥管理系统。
  - 退款接口需要商户退款证书（apiclient_cert.pem/apiclient_key.pem）的安全存储。
- 防重放：`nonce_str` + 签名校验即可
- IP 白名单：可将 `notify` 源 IP 与微信官方 IP 段校验（作为辅助手段，注意微信官方 IP 也会变化）
- 日志与审计：保存完整回调原文、响应、签名校验结果，便于纠纷与对账

---

# 8. 回调安全与正确响应
微信要求：
- 返回 `SUCCESS` 表示已成功处理回调；否则微信会重试若干次（间隔有退避），因此后端至少保证在能安全处理的情况下返回 `SUCCESS`。
- 切记：只有在你**已确认**订单金额、订单号、签名正确并已妥善更新订单后，才返回 `SUCCESS`。

示例回调响应（成功）：
```xml
<xml>
  <return_code><![CDATA[SUCCESS]]></return_code>
  <return_msg><![CDATA[OK]]></return_msg>
</xml>
```

---

# 9. 退款 / 对账
- 退款 API：调用微信退款接口需要商户证书（双向 SSL），检查退款状态并更新 `refunds` 表。
- 对账：每日生成对账单（微信有对账单下载接口），与本地 `payments`、`orders` 表对账，找出缺失/异常项并人工确认。
- 建议：实现自动对账脚本 + 告警（发现差额、回调失败次数、重复交易等）。

---

# 10. 错误/异常处理与测试
- 常见异常：
  - `unifiedorder` 返回 `SYSTEMERROR` / `SIGNERROR` / 网络超时 → 需重试（限次）或返回给前端失败并提示稍后再试。
  - `notify` 由于网络问题未能及时处理 → 微信会重发回调，多次重试确保幂等处理。
- 测试项：
  - 使用微信沙箱或测试商户账号进行 end-to-end 测试（统一下单、回调、退款、查询）
  - 模拟重复回调、延迟回调、金额不一致、网络超时、证书失效等场景
  - 前端二维码过期与刷新交互测试
  - 并发下单/并发回调的幂等保障测试
- 监控与告警：
  - 监控回调失败率、unifiedorder 失败率、退款失败率
  - 支付成功率 / 平均时延 / 日对账差额告警

---

# 11. 示例：后端伪代码（回调处理核心逻辑）
```java
// 接收微信回调（XML body）
String xml = request.getBody();
Map<String, String> data = parseXml(xml);
if (!verifySign(data, mchKey)) {
  // 记录并返回失败（微信会重试）
  return replyXml("FAIL", "signature error");
}
if (!"SUCCESS".equals(data.get("return_code")) || !"SUCCESS".equals(data.get("result_code"))) {
  return replyXml("FAIL", "wechat result failed");
}
String outTradeNo = data.get("out_trade_no");
int totalFee = Integer.parseInt(data.get("total_fee"));

// 幂等更新：使用数据库事务 + 状态判断
order = orderRepo.findByOutTradeNo(outTradeNo);
if (order == null) return replyXml("FAIL", "order not found");
if (order.status == PAID) {
  return replyXml("SUCCESS", "OK");
}
if (order.amount != totalFee) {
  // 记录异常并人工介入
  alertForManualCheck(order, data);
  return replyXml("FAIL", "amount mismatch");
}
// 更新订单状态、记录 payment 记录
transaction {
  order.status = PAID;
  order.paidAt = now();
  paymentRepo.insert(...); // 保存微信交易号等
}
notifyBusinessSystem(order);
return replyXml("SUCCESS", "OK");
```

---

# 12. 运营与产品建议（实务）
- 二维码有效期：通常 2–10 分钟；建议前端显示倒计时并自动刷新（生成新订单）。
- 退款策略：要在流程中明确退款规则和时间（T+0/T+1），并在 UI 中体现退款进度。
- 客服支持：出现支付异常时提供「我已付款」人工确认入口（便于客服核查微信回调/对账）。
- 记录流水号：对账和争议处理必须能把业务订单号、微信交易号、回调时间全部追踪到。

---

# 总结（快速清单）
- 使用 `unifiedorder`（`trade_type=NATIVE`）获取 `code_url` → 前端渲染二维码。
- 回调必须验签、金额一致、幂等更新并返回 `SUCCESS`。
- 前端用 WebSocket/SSE 推送或轮询检测支付结果，提供二维码过期/刷新机制。
- 严格保护商户密钥与退款证书；退款接口需客户端证书。
- 实现自动对账、异常告警、完整日志保存与人工介入流程。

---

如果你愿意，我可以：
1. 基于你现有的后端栈（Spring Boot / Node / Go）给出 **具体代码模板**（unifiedorder 请求、回调验签、二维码渲染、WebSocket 通知）；
2. 给出数据库建表 SQL 和可直接使用的 migration；
3. 或者设计一张详细的流程图/时序图（文本版或 mermaid 格式）以便直接放进设计文档。

你想先要哪一个？

# 秒杀





# 支付

