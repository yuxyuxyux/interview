好的，我给你详细整理 **Redis 哨兵（Sentinel）框架及心跳机制**，并附上原理和流程图思路。

------

## **1. Redis 哨兵框架概览**

Redis Sentinel 的核心职责：

1. **监控（Monitoring）**：不断检查主从实例状态。
2. **通知（Notification）**：发现异常时通知系统或管理员。
3. **自动故障转移（Failover）**：当主节点不可用时，选举新的主节点。
4. **配置提供者（Configuration Provider）**：客户端通过哨兵获取最新主节点信息。

### **1.1 架构组成**

```
      +-------------------+
      |      Sentinel     |
      | (监控/投票/通知) |
      +-------------------+
        |        |        \
   +---------+ +---------+ +---------+
   |  Master | |  Slave1 | |  Slave2 |
   +---------+ +---------+ +---------+
```

- **Master**：处理写请求
- **Slave**：同步主节点数据，可做读
- **Sentinel**：独立进程，至少 3 个，形成多数投票机制

> 注意：Sentinel 与 Redis 实例之间是**独立进程**，通过心跳检测和 pub/sub 进行通信。

------

## **2. 哨兵心跳机制**

### **2.1 心跳目的**

- 检测 Redis 实例是否可用
- 保证 Sentinel 对实例状态的实时感知

### **2.2 心跳流程**

1. **Sentinel 主动 PING**
   - Sentinel 定期发送 `PING` 命令检测主从实例是否存活。
   - 默认检测间隔：`sentinel down-after-milliseconds`（毫秒级）。
2. **实例响应 PONG**
   - Redis 节点收到 PING 返回 PONG，表示可用。
3. **主观下线（Subjective Down, SDOWN）**
   - 单个 Sentinel 若超过 `down-after-milliseconds` 未收到 PONG，则认为实例 SDOWN。
4. **客观下线（Objective Down, ODOWN）**
   - 多个 Sentinel 达成多数共识（Quorum）后，将实例标记为 ODOWN。
   - ODOWN 才会触发 **故障转移**。
5. **Sentinel 间心跳**
   - Sentinel 之间也互相 PING，通过 pub/sub 交换信息。
   - 确保多数 Sentinel 达成一致，避免单点误判。

------

## **3. 故障检测与投票机制**

### **3.1 选举机制**

- 当 ODOWN 发生时，Sentinel 之间发起投票：
  1. 确定哪些从节点有资格成为新主
  2. 进行主从提升（`SLAVEOF NO ONE`）
  3. 其他从节点指向新主
  4. 通知客户端

### **3.2 参数配置**

| 参数                      | 作用                                     |
| ------------------------- | ---------------------------------------- |
| `down-after-milliseconds` | Sentinel 认为实例不可用的超时时间        |
| `parallel-syncs`          | 故障转移时，同时允许多少从节点与新主同步 |
| `failover-timeout`        | 整个故障转移过程最大时间                 |
| `quorum`                  | Sentinel 认为实例不可用的最少票数        |

------

## **4. 心跳检测总结**

| 类型                    | 发送对象      | 周期                      | 判断条件                       |
| ----------------------- | ------------- | ------------------------- | ------------------------------ |
| **Sentinel → Redis**    | 主从节点      | `down-after-milliseconds` | 无 PONG → SDOWN                |
| **Sentinel → Sentinel** | 同级 Sentinel | pub/sub 心跳              | 互通信息，判断多数意见 → ODOWN |

**核心逻辑：**

```
PING→PONG  → OK
PING 超时 → SDOWN（主观下线）
多数 Sentinel 达成共识 → ODOWN（客观下线）
ODOWN → 发起故障转移
```

------

## **5. 心跳与故障转移完整流程**

```
[Sentinel1, Sentinel2, Sentinel3] 监控 Master

Step1: Sentinel PING Master → PONG
        |        \
       OK        Master 不响应
Step2: Sentinel 标记 Master SDOWN
Step3: Sentinel 间互通信息 → 达成 Quorum
Step4: Master ODOWN → 发起故障转移
Step5: 从节点提升为新主
Step6: 其他从节点同步新主
Step7: Sentinel 通知客户端
```

> 💡 特点：
>
> - 所有 Sentinel 独立投票，保证高可用
> - 心跳是 **毫秒级**，可快速感知节点故障
> - 故障转移是**半自动化**，可保证数据一致性

------

如果你希望，我可以帮你画一张 **Redis 哨兵心跳 + 故障转移流程图**，清楚显示 Sentinel 与 Master/Slave 的心跳、投票和主从切换流程，非常直观。

你希望我画吗？



好的，我给你系统梳理一下 **Redis 哨兵系统（Redis Sentinel）**，它是 Redis 官方提供的高可用解决方案。内容包括概念、原理、架构和部署使用。

------

## **1. Redis 哨兵系统概念**

Redis Sentinel 主要作用是：

1. **监控（Monitoring）**：监控主从实例是否健康。
2. **通知（Notification）**：当发现问题时通知运维或应用。
3. **自动故障转移（Automatic Failover）**：主节点宕机时，自动将某个从节点提升为新的主节点，并让其他从节点重新复制它。
4. **配置提供者（Configuration Provider）**：客户端可通过哨兵获取当前主节点地址，保证应用连接可用。

------

## **2. 哨兵架构**

### **2.1 组成**

- **主节点（Master）**：负责写入操作
- **从节点（Slave）**：负责复制主节点数据，可读操作
- **哨兵节点（Sentinel）**：
  - 监控主从状态
  - 协商故障转移
  - 提供最新主节点信息给客户端

### **2.2 集群示意**

```
         +---------+
         | Master  |
         +---------+
         /        \
   +---------+  +---------+
   | Slave1  |  | Slave2  |
   +---------+  +---------+
      |           |
   +-----------+-----------+
   | Sentinel1 Sentinel2  Sentinel3
   +----------------------+
```

- **至少 3 个哨兵**，保证可用多数（Quorum）进行主从切换
- 哨兵通过 **心跳检测**主从状态

------

## **3. 工作原理**

### **3.1 监控**

- Sentinel 定期向主从发送 `PING` 检测可用性
- 当某个实例超过超时时间未响应，标记 **Subjectively Down（SDOWN）**

### **3.2 故障判断**

- 多个 Sentinel 发现同一主节点不可用，达到 **多数票（Quorum）**
- Sentinel 将主节点标记为 **Objectively Down（ODOWN）**

### **3.3 故障转移**

1. 选举新主节点（从节点中选）
2. 提升从节点为新主节点（`SLAVEOF NO ONE`）
3. 其他从节点指向新主节点 (`SLAVEOF new-master`)
4. 通知应用客户端最新主节点地址

### **3.4 配置提供者**

- 客户端可配置哨兵集群地址
- 当主节点切换时，客户端从哨兵获取新主节点连接信息，实现无感知切换

------

## **4. 配置示例**

### **4.1 主从配置**

```conf
# master.conf
port 6379
requirepass yourpassword
# slave.conf
port 6380
slaveof 127.0.0.1 6379
masterauth yourpassword
```

### **4.2 哨兵配置**

```conf
port 26379
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel auth-pass mymaster yourpassword
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 10000
sentinel parallel-syncs mymaster 1
```

解释：

- `mymaster`：监控的主节点名称
- `2`：Quorum，即至少 2 个哨兵同意故障转移
- `down-after-milliseconds`：主节点多久没响应算 SDOWN
- `failover-timeout`：故障转移超时

------

## **5. 优势与注意事项**

### **5.1 优势**

- 高可用自动化
- 无需额外代理，客户端可直接连接 Sentinel
- 支持主节点宕机自动切换

### **5.2 注意事项**

- Sentinel 需 **奇数个节点**（推荐 ≥3）
- 主从节点需开启 **AOF/RDB** 持久化
- 客户端需支持 Sentinel 模式获取最新主节点
- 大规模集群可结合 **Redis Cluster** 使用

------

💡 **总结**
 Redis Sentinel 是 Redis 官方推荐的高可用方案：

1. 监控主从健康
2. 自动主从切换
3. 提供最新主节点信息给客户端

与 Redis Cluster 不同，Sentinel 适合 **单主多从的高可用场景**，而 Redis Cluster 适合 **数据分片的横向扩展场景**。

------

如果你希望，我可以帮你画一张 **Redis 哨兵系统架构图 + 故障转移流程图**，清楚展示主从切换和哨兵投票过程。

你希望我画吗？