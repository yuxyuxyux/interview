非常好 👍
 你问的 **MVCC（Multi-Version Concurrency Control，多版本并发控制）** 是数据库面试中非常高频的知识点，尤其在 **MySQL（InnoDB 引擎）** 中。

我来帮你系统、分层地讲解它，从概念 → 原理 → 实现机制 → 可见性规则 → 事务隔离级别。

------

## 🧭 一、MVCC 是什么

> **MVCC（多版本并发控制）** 是一种用于 **实现并发事务时读写互不阻塞** 的机制。

它的核心思想是：

> 每个事务看到的数据库状态都是 **某个时间点的快照（Snapshot）**，
>  而不是当前正在被其他事务修改的最新数据。

👉 这样就可以做到：

- **读操作不阻塞写操作**（读不加锁）
- **写操作不阻塞读操作**（写生成新版本）

------

## ⚙️ 二、为什么要有 MVCC？

假设没有 MVCC，我们就只能通过加锁来保证一致性：

| 操作                           | 无 MVCC 结果 | 有 MVCC 结果             |
| ------------------------------ | ------------ | ------------------------ |
| 一个事务读数据时另一个事务修改 | 读被阻塞     | 读到旧版本（快照）       |
| 写时另一个读                   | 写阻塞       | 写生成新版本，读不受影响 |
| 读时另一个读                   | 都可以执行   | 都可以执行               |

✅ **目的：提高数据库的并发性能，同时保证事务隔离性。**

------

## 🧩 三、MVCC 核心组成（InnoDB 实现）

### 1️⃣ 隐藏字段（3 个）

每一行记录 InnoDB 会自动添加隐藏字段：

| 字段          | 含义                                              |
| ------------- | ------------------------------------------------- |
| `DB_TRX_ID`   | 最后一次修改（insert/update/delete）该行的事务 ID |
| `DB_ROLL_PTR` | 回滚指针（指向 undo log，用于找旧版本）           |
| `DB_ROW_ID`   | 行 ID（单调递增，仅在无主键时存在）               |

------

### 2️⃣ Undo Log（回滚日志）

保存了数据的**旧版本**。

举例：

```text
事务 A 修改 row(x=10 → 20)
```

Undo Log 里保存：

```
旧版本：x=10
```

👉 如果其他事务需要查看修改前的值，就可以顺着 `DB_ROLL_PTR` 找到旧版本。

------

### 3️⃣ ReadView（读视图）

事务在执行 **快照读** 时，会生成一个 `ReadView`，
 它决定当前事务能“看到”哪些版本的记录。

**ReadView 包含的 4 个核心字段：**

| 字段             | 含义                                      |
| ---------------- | ----------------------------------------- |
| `m_ids`          | 当前系统中活跃（未提交）的事务 ID 列表    |
| `min_trx_id`     | 当前最小活跃事务 ID（m_ids 最小值）       |
| `max_trx_id`     | 下一个将被分配的事务 ID（最大事务号 + 1） |
| `creator_trx_id` | 当前创建 ReadView 的事务 ID               |

------

## 🔍 四、可见性规则（MVCC 读写规则）

当事务读取一行数据时，判断该行版本是否可见的规则如下：

| 判断条件                      | 是否可见                       |
| ----------------------------- | ------------------------------ |
| 若 `DB_TRX_ID` < `min_trx_id` | ✅ 可见（在快照创建前已提交）   |
| 若 `DB_TRX_ID` ≥ `max_trx_id` | ❌ 不可见（在快照创建后才开启） |
| 若 `DB_TRX_ID` 在 `m_ids` 中  | ❌ 不可见（事务仍未提交）       |
| 否则                          | ✅ 可见（在快照创建时已提交）   |

👉 如果当前版本不可见，就沿着 `DB_ROLL_PTR` 去找上一个版本（旧快照），直到找到可见的为止。

------

## 📘 五、两种读操作

| 类型                        | 说明                        | 是否使用 MVCC |
| --------------------------- | --------------------------- | ------------- |
| **快照读（Snapshot Read）** | 读历史版本（普通 `SELECT`） | ✅ 使用        |
| **当前读（Current Read）**  | 读最新版本（带锁）          | ❌ 不使用      |

📌 **举例：**

```sql
-- 快照读
SELECT * FROM user WHERE id = 1;

-- 当前读（会加锁）
SELECT * FROM user WHERE id = 1 FOR UPDATE;
UPDATE user SET name='Tom' WHERE id=1;
DELETE FROM user WHERE id=1;
```

------

## 🧱 六、事务隔离级别与 MVCC 关系

| 隔离级别                | 是否使用 MVCC | ReadView 生成时机         | 能否重复读到相同快照       |
| ----------------------- | ------------- | ------------------------- | -------------------------- |
| READ UNCOMMITTED        | ❌             | 无                        | 不使用快照（可读到未提交） |
| READ COMMITTED          | ✅             | 每次查询生成新的 ReadView | ❌ 不可重复读               |
| REPEATABLE READ（默认） | ✅             | 第一次查询生成 ReadView   | ✅ 可重复读                 |
| SERIALIZABLE            | ❌             | 强制加锁                  | 完全串行化                 |

✅ **InnoDB 默认是 REPEATABLE READ，通过 MVCC 实现可重复读。**

------

## 🧠 七、举例说明

假设表中有：

```text
id = 1, name = "Alice"
```

事务 T1：

```sql
START TRANSACTION;
SELECT name FROM user WHERE id = 1;  -- 读到 Alice
```

事务 T2：

```sql
START TRANSACTION;
UPDATE user SET name = 'Bob' WHERE id = 1;
COMMIT;
```

T1 再执行：

```sql
SELECT name FROM user WHERE id = 1;  -- 还是读到 Alice（因为使用快照）
```

👉 T1 的 ReadView 早已创建，指向事务开始时的版本，因此读不到 T2 提交的新值。
 直到 T1 提交后，下次查询才会看到更新后的值。

------

## 🧾 八、MVCC 与锁的关系

| 类型       | 是否加锁 | 用途           |
| ---------- | -------- | -------------- |
| **快照读** | 不加锁   | 提高并发性能   |
| **当前读** | 加锁     | 保证修改安全性 |

**MVCC ≠ 锁机制**，它是一种 **无锁的读一致性方案**，与锁并行使用（写时仍需加锁）。

------

## 🧩 九、总结表

| 概念         | 含义                              |
| ------------ | --------------------------------- |
| MVCC         | 多版本并发控制，读写不阻塞        |
| Undo Log     | 存储旧版本记录                    |
| ReadView     | 定义事务能看到哪些版本            |
| 隐藏列       | DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID |
| 快照读       | 不加锁，通过 MVCC 实现一致性读    |
| 当前读       | 加锁，读取最新数据                |
| 默认隔离级别 | REPEATABLE READ（可重复读）       |

------

是否希望我为你画一张 **MVCC 可见性判断流程图**（事务快照、版本链、ReadView 判断）？
 能直观看出多个事务间数据版本的演变。