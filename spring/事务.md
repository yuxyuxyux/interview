非常好，这个题是 **Spring / 微服务 / 中间件面试** 的高频核心考点之一。下面我给你一个系统化总结，内容分为四块：

------

## 一、Spring 事务基础（本地事务）

### 1️⃣ 事务的四大特性（ACID）

| 特性         | 含义                                     |
| ------------ | ---------------------------------------- |
| **A 原子性** | 整个事务要么全部成功，要么全部失败回滚。 |
| **C 一致性** | 事务执行前后，数据必须保持一致状态。     |
| **I 隔离性** | 并发事务之间相互隔离，避免干扰。         |
| **D 持久性** | 一旦提交，数据永久保存，即使系统崩溃。   |

------

### 2️⃣ Spring 事务传播行为（Propagation）

| 类型                 | 含义                                               |
| -------------------- | -------------------------------------------------- |
| **REQUIRED（默认）** | 如果存在事务则加入，否则新建事务。                 |
| **REQUIRES_NEW**     | 不管有没有事务，都新建一个事务，挂起外部事务。     |
| **SUPPORTS**         | 如果有事务就加入，没有就非事务执行。               |
| **NOT_SUPPORTED**    | 不支持事务，若存在事务则挂起。                     |
| **MANDATORY**        | 必须在事务中执行，否则抛异常。                     |
| **NEVER**            | 必须在非事务中执行，否则抛异常。                   |
| **NESTED**           | 若有事务则嵌套执行，可独立回滚（基于 savepoint）。 |

------

### 3️⃣ 事务隔离级别（Isolation）

| 级别                 | 对应问题                                        | 描述 |
| -------------------- | ----------------------------------------------- | ---- |
| **READ_UNCOMMITTED** | 脏读、不可重复读、幻读都可能发生                |      |
| **READ_COMMITTED**   | 避免脏读，但可能不可重复读和幻读（Oracle 默认） |      |
| **REPEATABLE_READ**  | 避免脏读、不可重复读，但可能幻读（MySQL 默认）  |      |
| **SERIALIZABLE**     | 严格串行化，性能最差但最安全                    |      |

------

### 4️⃣ Spring 事务管理的两种方式

#### ✅ 编程式事务

使用 `TransactionTemplate` 或 `PlatformTransactionManager` 手动控制。

```java
transactionTemplate.execute(status -> {
    try {
        userMapper.insert(user);
        accountMapper.update(...);
    } catch (Exception e) {
        status.setRollbackOnly();
    }
    return null;
});
```

#### ✅ 声明式事务（常用）

使用 `@Transactional` 注解：

```java
@Service
public class OrderService {
    @Transactional(rollbackFor = Exception.class)
    public void createOrder() {
        saveOrder();
        deductStock(); // 抛异常则回滚
    }
}
```

------

### 5️⃣ Spring 事务生效的前提与坑

| 问题                 | 原因                                                         |
| -------------------- | ------------------------------------------------------------ |
| 同类内部方法调用失效 | 因为事务是通过代理实现，self-invoke 无法走代理。             |
| 非 public 方法无效   | JDK 动态代理只对 public 生效。                               |
| 异常不触发回滚       | 默认只回滚 `RuntimeException`，checked 需 `rollbackFor` 指定。 |
| 未交给 Spring 管理   | 事务 AOP 未生效。                                            |
| 多数据源             | 只能管理单个数据源。                                         |

------

## 二、分布式事务核心概念

> 当一次业务操作涉及多个服务 / 数据源时，**本地事务无法保证全局一致性**，这就需要分布式事务。

------

### 1️⃣ 理论基础

#### ① CAP 定理

- **C 一致性（Consistency）**
- **A 可用性（Availability）**
- **P 分区容错性（Partition tolerance）**
   → 分布式系统最多同时满足两项。

#### ② BASE 理论（最终一致性思想）

- **Basically Available**：基本可用
- **Soft State**：软状态
- **Eventually Consistent**：最终一致性

------

### 2️⃣ 常见的分布式事务方案

| 模式                                | 核心思想                                        | 优点               | 缺点               | 框架示例           |
| ----------------------------------- | ----------------------------------------------- | ------------------ | ------------------ | ------------------ |
| **2PC（两阶段提交）**               | 协调者通知所有参与者预提交 → 全部确认后正式提交 | 简单               | 同步阻塞、单点风险 | XA / Atomikos      |
| **3PC（三阶段提交）**               | 改进 2PC，增加超时与预备阶段                    | 降低阻塞风险       | 实现复杂           | 理论性             |
| **TCC（Try-Confirm-Cancel）**       | 业务层拆三步：预留资源、确认、撤销              | 性能好、灵活       | 实现复杂、强侵入   | Seata TCC、ByteTCC |
| **本地消息表 / 可靠消息最终一致性** | 本地事务 + MQ 确认机制                          | 实现简单、异步高效 | 延迟一致           | RocketMQ、Kafka    |
| **Saga 模式**                       | 一系列有补偿动作的本地事务                      | 解耦性强           | 一致性较弱         | Seata Saga、LRA    |
| **Seata AT 模式**                   | 基于数据库 undo log 自动回滚                    | 无侵入、易用       | 仅支持部分数据库   | Seata              |

------

### 3️⃣ 分布式事务框架选型

| 场景             | 推荐方案                        |
| ---------------- | ------------------------------- |
| 同一数据库多表   | Spring 本地事务即可             |
| 多库但同服务内   | Seata AT                        |
| 多微服务         | TCC / Saga                      |
| 异步消息驱动场景 | 本地消息表 或 RocketMQ 事务消息 |

------

## 三、Spring + 分布式事务整合方式

### ✅ Seata 整合示例

1. 引入依赖：

```xml
<dependency>
    <groupId>io.seata</groupId>
    <artifactId>seata-spring-boot-starter</artifactId>
    <version>2.0.0</version>
</dependency>
```

1. 配置：

```yaml
seata:
  enabled: true
  tx-service-group: my_tx_group
  service:
    vgroup-mapping:
      my_tx_group: default
  registry:
    type: nacos
```

1. 业务中使用：

```java
@GlobalTransactional(name = "create_order_tx", rollbackFor = Exception.class)
public void createOrder() {
    orderService.createOrder();
    stockService.deduct(); // 分布式调用
}
```

------

## 四、面试高频题（附答案简要）

### 🔹 基础篇

1️⃣ **@Transactional 为什么有时不生效？**
 → 内部调用、非 public、未代理、异常类型不匹配、未托管 Bean。

2️⃣ **Spring 事务默认传播级别？**
 → `Propagation.REQUIRED`

3️⃣ **如何手动回滚事务？**
 → `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();`

------

### 🔹 进阶篇

4️⃣ **2PC 的流程和缺点？**
 → 准备阶段（预提交）+ 提交阶段（全提交）。缺点：同步阻塞、协调者单点故障。

5️⃣ **TCC 模式核心思想？**
 → 业务分三步：Try 预留资源、Confirm 提交、Cancel 撤销，保证最终一致。

6️⃣ **Saga 与 TCC 的区别？**

| 对比   | TCC        | Saga     |
| ------ | ---------- | -------- |
| 控制层 | 业务方控制 | 框架编排 |
| 隔离   | 强         | 弱       |
| 侵入性 | 强         | 弱       |
| 一致性 | 强         | 最终一致 |

7️⃣ **Seata 的 AT 模式原理？**
 → 基于全局事务 + UndoLog 实现自动回滚，框架拦截 SQL，记录前后镜像。

8️⃣ **本地消息表的实现原理？**
 → 在本地事务中写入业务数据 + 消息表，MQ 异步消费发送，保证最终一致。

9️⃣ **幂等性如何保障？**
 → 唯一业务号、幂等表、状态机控制、去重 Token、Redis SetNX。

------

### 🔹 场景题

10️⃣ **下单扣库存涉及两个微服务，如何保证一致？**
 ✅ 可选方案：

- 使用 **Seata AT / TCC 模式**
- 使用 **本地消息表 + MQ** 最终一致性
- 或 **Saga 补偿模式**

11️⃣ **订单服务超时，库存已扣，怎么补偿？**
 → Saga 模式触发补偿动作（库存回滚）。

------

是否希望我帮你把这些内容整理成一份可打印的 **《Spring 事务与分布式事务面试宝典.md》** 文件（含代码与图解）？
 我可以自动生成并打包下载。